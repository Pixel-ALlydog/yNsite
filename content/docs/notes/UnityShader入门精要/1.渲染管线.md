---
date: 2024-02-20
title: 1、图形渲染管线
weight: 1
---

# 图形渲染管线（Rendering Pipline）
图形渲染流程从概念上可以简单分为三个阶段：
- 应用阶段(Application Stage)
- 几何阶段(Geometry Stage)
- 光栅化阶段(Rasterizer Stage)

![图形渲染管线](https://s2.loli.net/2024/02/21/QbMB1S2nedpPlz5.png)

## 应用阶段
由开发者主导，通常在CPU中实现。主要有三个任务：
1. 准备场景数据，如相机位置、视锥体、场景中的模型、光源等
2. 为了提高性能，需要做一个粗粒度（culling）工作，剔除不可见物体
3. 设置每个模型的渲染状态，如模特使用的材质（漫反射颜色、高光反射颜色）、使用的纹理、Shader等

这一阶段最重要的输出是渲染所需的几何信息，即渲染图元（rendering primitives），之后交给几何阶段。

## 几何阶段
这两个阶段有许多子流水线，在GPU中执行

### **顶点着色器**
通常用于实现顶点的空间变换、顶点着色等功能。

顶点着色器本身并不可以创建或者销毁任何顶点，且无法得到顶点与顶点之间的关系。

主要完成坐标变换和逐顶点光照。

### **曲面细分着色器**
用于细分图元
### **几何着色器**
用于执行逐图元着色操作，或者被用于产生更多图元
### **裁剪**
一个图元和摄像机视野的关系有3种：完全在视野内、部分在视野内、完全在视野外

这个阶段会将不在摄像机视野内的顶点裁剪掉，剔除某些三角图元的面片
### **屏幕映射**
屏幕映射主要把每个图元的x和y坐标转换到屏幕空间坐标上。

## 光栅化阶段
### **三角形设置**
从这开始到光栅化阶段，光栅化阶段有两个重要目标：
- 计算每个图元覆盖了哪些像素
- 为这些覆盖的像素计算颜色

三角形设置会计算光栅化一个三角形网络所需的信息。
### **三角形遍历**
三角形遍历会检查每个像素是否被一个三角网络所覆盖，如果被覆盖，就会生成一个片元。
### **片元着色器**
在前面的光栅化阶段中，并不会实际影响屏幕上像素的颜色值，而是产生一系列数据信息，用来表达一个三角形网络
是怎样覆盖每个像素的。真正对像素产生影响的是下一个阶段--逐片元操作

片元着色器的输入从上一个阶段得到，这个阶段的输出是一个或多个颜色值。

在这个阶段可以完成很多重要的渲染技术。
### **逐片元操作**
这个阶段主要任务有：
- 决定每个片元的可见性，模板测试、深度测试等
- 如果一个片段通过了所有测试，就需要把这个片元的颜色和已经存储在颜色缓冲区的颜色进行合并（混合）

这个阶段是可配置的，可以选择是否开启测试，或者使用混合。

#### 模板测试
如果开启了模板测试，GPU首先读取模板缓冲区中该片元的模板值，然后和读取到的参考值进行比较，比较函数则由开发者指定。

不管一个片元有没有通过模板测试，都可以根据模板测试和深度测试结果来修改模板缓冲区，修改操作也是由开发者指定。

一些高级的用法如渲染阴影、轮廓渲染等

#### 深度测试
如果开启了深度测试，GPU会把该片元深度值与深度缓冲区中的深度值进行比较。

与模板测试不同，如果一个片元没有通过测试，则无法修改深度缓冲区的值。

#### 混合
在透明物体的情况下，就需要开启混合，这样片元着色器计算得到的颜色值就会让物体看起来是透明的。否则会直接覆盖片元

当图元经过了种种测试之后，最终会显示到屏幕上，屏幕显示的值即为颜色缓冲值。

## 双重缓冲（Double Buffering）
为了避免我们看到正在进行光栅化的图元，GPU会使用双重缓冲策略。

意味着场景的渲染是在幕后进行的，也就是后置缓冲（Back Buffer）里。\
一旦场景被渲染到了后置缓冲中，GPU就会交换后置缓冲和前置缓冲（Front Buffer）中的内容，
而前置缓冲也就是显示在屏幕上的图像。

由此，保证了看到的图形总是连续的。

## 关于Draw Call
CPU在完成各种数据分配后就会调用DrawCall来到下一个阶段（几何阶段）。

CPU和GPU中使用了命令缓冲区来实现并行工作，DrawCall是其中的一种（其它如改变渲染状态、改变使用的着色器、使用不同的纹理等）。

每次使用DrawCall之前，CPU完成很多准备工作后才轮到GPU工作，一般GPU渲染速度往往快于CPU提交指令的速度。如果DrawCall数量太多，CPU会把大量时间花在提交Draw Call上，造成CPU过载。

### 减少Draw Call
这里仅讨论批处理（Batching）方法，批处理更适合静态的物体，如地面、石头等。

对于动态物体进行批处理，则每一帧都需要重新进行合并然后发送给GPU，对空间要求较高。

为了减少Draw Call的开销，需要注意：
- 避免使用大量很小的网络，当不可避免时，考虑是否可以合并它们
- 避免使用过多的材质，尽量在不同的网络之间共用同一个材质
