---
date: 2024-03-11
title: Texture
weight: 1
---
# 纹理显示
在纹理坐标系下，纹理中每个像素称为纹素（texel）。在对纹理进行采样之后，最终显示到屏幕的像素中。

## 纹理采样
比较直接的方法是让纹素一一对一到屏幕像素上；

若想让**小纹理显示在大屏幕中**，可以想象以每个纹素中心为一点，将纹理拉伸到屏幕大小，那么纹素点的密度变大，此时以每个像素中心做采样点，常见的采样方法有：
- 最邻近插值(Nearest)，取采样点周围4点中最近的纹素值，快速但有较多锯齿
- 双线性插值(Bilinear)，用取采样点周围4点距离做线性插值，效果较平滑
- 双三次插值(Bicubic)，用取采样点周围16点做插值，效果平滑，运算量大


若想让**大纹理显示在小屏幕中**，则比较麻烦，直接使用点取样的方法，会出现走样，产生摩尔纹。

### 摩尔纹
一般以每个屏幕像素的中心作为一个采样点，直接使用点取样，对于纹理中变化不大的区域（平滑区域）可以认为是该点的平均（并没有计算均值只是变化不大认为该点为该区域的值），但是对于纹理中剧烈变化的区域（多边缘），用取样点表示则无法接受（出现失真，即摩尔纹）。

**纹理中变化慢的区域可以认为是低频区域，而变化快的区域是高频区域。**

摩尔纹的出现本质上是取样率不够造成的。想要削除摩尔纹，在每一个像素中设置更多的取样点对纹理进行取样求平均即可，但是这样会导致更大的性能开销。

但其实反过来可以降低纹理频率，让高频部分不再高频，就可以接受取样点表示这些区域。那么在纹理上去掉高频部分的操作就是**模糊**。

## Mipmap
在一张纹理中进行多次模糊（一般是每次分辨率小一半）并存储起来，该纹理被称为mipmap，同时为了更快速的范围查询（近似）纹理中纹素的位置，mipmap需要是正方形的（或者接近正方形）。使用mipmap会让纹理多33%的大小。

现在回到之前想让大纹理显示在小屏幕中的问题，只需要在采样点中范围查询mipmap对应层级的纹素即可。以下为范围查询的方法：
{{< katex display >}}
L = max(\sqrt{(\frac{du}{dx})^2 + (\frac{dv}{dx})^2}, \sqrt{(\frac{du}{dy})^2 + (\frac{dv}{dy})^2})
{{< /katex >}}

{{< katex display >}}
D = log_2L
{{< /katex >}}
D为mipmap层级，L为距离。首先从屏幕坐标映射到纹理坐标中，使用x，y方向上的相邻像素计算对应u、v中相邻像素的长度，取距离最大的作为边长，找到对应层级的纹素。

### 三线性插值
使用mipmap会出现屏幕图像中mipmap纹理层级之间的变化不连续的问题，可以对该层与下一层级做双线性插值，在两层级之间的结果再进行双线性插值，经过三步插值后就可以有一个平滑的结果。

mipmap仍然有局限，虽然对于纹理的高频区域效果上比直接进行点采样的效果要好，但是这看起来会很糊（Overblur）。

### 各项异性过滤
mipmap中，对纹理长宽进行等比例压缩（压缩后仍然是正方形）。使用各项异性过滤则分别对纹理的长宽进行压缩（Ripmap,压缩后为长方形），对这种纹理进行范围查询可以缓解一部分问题（细节更多，但仍然是近似）。

使用各项异性过滤会比使用mipmap占用更多内存，会比原始纹理大4倍。
