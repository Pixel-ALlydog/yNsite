---
title: "4、坐标系统，摄像机"
weight: 5
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
---

在实现摄像机的功能之前，需要了解各种坐标系统。

# 坐标系统
关于坐标系统比较重要的有
- 局部空间（Local Space），也叫物体空间（Object Space）
- 世界空间（World Space）
- 观察空间（View Space），也叫视觉空间（Eye Space）
- 裁剪空间（Clip Space）
- 屏幕空间（Screen Space）

OpenGL在顶点着色器运行后会将所有超出[-1,1]范围的顶点坐标视为不可见。
通常会设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。

每个坐标系统间的转换通常是分步进行的，在物体坐标转换为屏幕坐标之前，还有几步的坐标系统的转换。

将物体的坐标变换到几个过渡坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易。

## MVP
最初的局部坐标会经过变换变为世界坐标，观察坐标，裁剪坐标，最后是屏幕坐标。

![](https://cdn.jsdelivr.net/gh/Pixel-ALlydog/blog-img/opengl/coordinate_systems.png)

1. 局部坐标也就是物体的局部的坐标系统，通过**模型矩阵**（Model Matrix）变换到世界坐标
2. 世界坐标可以理解为摆放各个物体位置的坐标，有一个全局的原点，通过**观察矩阵**（View Matrix）变换到观察坐标
3. 观察坐标则相对于观察者所看的各个物体间的坐标，通过**投影矩阵**（Projection Matrix）变换到裁剪坐标
4. 坐标到达观察空间之后，我们需要将其投影到裁剪坐标。裁剪坐标会被处理至-1.0到1.0的范围内，并判断哪顶点将会出现在屏幕上。
5. 裁剪坐标会转换为屏幕坐标，这将会使用一个视口变换（Viewport Transform），将位于-1.0到1.0范围的标变换到由glViewport函数所定义的坐标范围内。最后变换出来的坐标将会送到光栅器，将其转化为片段，也就我们屏幕上看到的画面

### 裁剪空间
对于裁剪空间，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。

因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。

为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。

由投影矩阵创建的观察箱(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。

将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个正射投影矩阵(Orthographic Projection Matrix)或一个透视投影矩阵(Perspective Projection Matrix)。

### 正射投影（正交投影）
创建一个正射投影矩阵需要指定可见平截头体的宽、高和长度。在使用正射投影矩阵变换至裁剪空间之后处于这个平截头体内的所有坐标将不会被裁剪掉。它由由宽、高、近(Near)平面和远(Far)平面所指定。

![](https://cdn.jsdelivr.net/gh/Pixel-ALlydog/blog-img/opengl/orthographic_frustum.png)

正射平截头体直接将平截头体内部的所有坐标映射为标准化设备坐标，因为每个向量的w分量都没有进行改变；如果w分量等于1.0，透视除法则不会改变这个坐标。

要创建一个正射投影矩阵，我们可以使用GLM的内置函数glm::ortho：
```c++
glm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);
```
前两个参数指定了平截头体的左右坐标，
第三和第四参数指定了平截头体的底部和顶部，
然后第五和第六个参数则定义了近平面和远平面的距离。

### 透视投影
在正交投影的基础上，透视投影有着近大远小的效果。这个投影矩阵将给定的平截头体范围映射到裁剪空间，除此之外还修改了每个顶点坐标的w值，从而使得离观察者越远的顶点坐标w分量越大。被变换到裁剪空间的坐标都会在-w到w的范围之间（任何大于这个范围的坐标都会被裁剪掉）。

![](https://cdn.jsdelivr.net/gh/Pixel-ALlydog/blog-img/opengl/perspective_frustum.png)

OpenGL要求所有可见的坐标都落在-1.0到1.0范围内，作为顶点着色器最后的输出，因此，一旦坐标在裁剪空间内之后，透视除法就会被应用到裁剪空间坐标上：
{{< katex display >}}
out = 
\left(\begin{matrix}
   x/w \\
   y/w \\
   z/w 
  \end{matrix}\right)
{{< /katex >}}
顶点坐标的每个分量都会除以它的w分量，距离观察者越远顶点坐标就会越小。

```c++
glm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);
```
第一个参数定义了fov的值，它表示的是视野(Field of View)，并且设置了观察空间的大小。如果想要一个真实的观察效果，它的值通常设置为45.0f，但想要一个末日风格的结果你可以将其设置一个更大的值。

第二个参数设置了宽高比，由视口的宽除以高所得。

第三和第四个参数设置了平截头体的近和远平面。我们通常设置近距离为0.1f，而远距离设为100.0f。所有在近平面和远平面内且处于平截头体内的顶点都会被渲染。

关于fov的值可以参考下图：

![](https://cdn.jsdelivr.net/gh/Pixel-ALlydog/blog-img/opengl/v2-1eabd52cce329b12ec605cedb0901086_720w.jpg)


## MVP变换
一个顶点坐标经过MVP变换后变为裁剪坐标：
{{< katex display >}}
B = P\cdot V\cdot M\cdot A
{{< /katex >}}
最后的顶点应该被赋值到顶点着色器中的gl_Position。

OpenGL然后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，通过使用glViewPort内部的参数来将标准化设备坐标映射到屏幕坐标，每个坐标都关联了一个屏幕上的点。这个过程称为视口变换。


# 摄像机
OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。（没错，在OpenGL中动的不是摄像机是物体！）

## 观察空间
当讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。

要定义一个摄像机，我们需要它在世界空间中的位置、观察的方向、一个指向它右侧的向量以及一个指向它上方的向量。也就是以相机为原点的坐标系统。

![](https://cdn.jsdelivr.net/gh/Pixel-ALlydog/blog-img/opengl/camera_axes.png)

### 相机位置及方向

首先要知道-z轴是我们正对着屏幕的方向， 也是摄像机在观察坐标系统中所看的方向。

摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量（认为是个顶点就好了）。

摄像机所指方向，就是原点坐标减去摄像机的位置坐标，这也是-z轴的方向。
所以对于相机的坐标系统z轴就是摄像机位置坐标减去原点坐标，再进行标准化。

另外一个向量是右向量，也就是x轴的方向。为了得到x轴只需要将世界坐标中一个向上的向量对z轴方向叉乘即可得到。

最后的y轴，只需要用z轴方向于x轴方向叉乘即可得到。

现在有了这些摄像机向量，就可以创建一个LookAt矩阵。


## Look At
现在只需要将摄像机移到原点，并将其旋转摆正即可。

移到原点很简单，只需要减去原先设置的顶点位置即可（设位置为p）。

对于旋转，我们假设现在相机的坐标系统由原来的世界坐标系统旋转变换得到：
{{< katex display >}}
\left(\begin{matrix}
   x_r & x_u & x_d & 0\\
   y_r & y_u & y_d & 0\\
   z_r & z_u & z_d & 0\\
   0   & 0 & 0 & 1
  \end{matrix}\right)
  =R \cdot 
  \left(\begin{matrix}
   1 & 0 & 0 & 0\\
   0 & 1 & 0 & 0\\
   0 & 0 & 1 & 0\\
   0 & 0 & 0 & 1
  \end{matrix}\right)
{{< /katex >}}

那么现在想将其变回去只需要再乘以原先变换矩阵的逆即可，也就是R（正交矩阵）的转置
{{< katex display >}}
R^{-1} = 
  \left(\begin{matrix}
   x_r & y_r & z_r & 0\\
   x_u & y_u & z_u & 0\\
   x_d & y_d & z_d & 0\\
   0 & 0 & 0 & 1
  \end{matrix}\right)
{{< /katex >}}

所以LookAt矩阵为：
{{< katex display >}}
LookAt = 
\left(\begin{matrix}
   x_r & y_r & z_r & 0\\
   x_u & y_u & z_u & 0\\
   x_d & y_d & z_d & 0\\
   0 & 0 & 0 & 1
  \end{matrix}\right)
  \cdot 
\left(\begin{matrix}
   1 & 0 & 0 & -p_x\\
   0 & 1 & 0 & -p_y\\
   0 & 0 & 1 & -p_z\\
   0 & 0 & 0 & 1
  \end{matrix}\right)
{{< /katex >}}


到目前为止，有了MVP变换，已经可以做到3D场景的显示，不再像之前只有一个2D的三角形。