---
date: 2023-12-22
title: 12.类和动态内存分配
weight: 12
---
# 12. 类和动态内存分配
## 12.1 动态内存和类
不能在类中初始化静态成员变量，除非静态数据为整形或枚举型const。
无论创建多少对象，程序都只创建一个静态变量副本。

在构造函数中使用new分配内存时，必须在析构函数使用delete释放内存。
如果有多个构造函数，则必须以相同的方式使用new，要么都带[]，要么都不带。

对象的存储持续性为自动或外部时，会自动调用析构函数。
使用new为对象分配内存后，在使用delete时自动调用析构函数。


**特殊成员函数**
如果没有定义相应的函数，c++自动提供了：
- 默认构造函数
- 默认析构函数
- 复制构造函数
- 赋值运算符
- 地址运算符

c++11提供了另外两个特殊成员函数：
- 移动构造函数
- 移动赋值运算符


**复制构造函数**
复制构造函数用于将一个对象复制到创建新的对象中，用于初始化过程中，而不是常规的赋值过程中。
```c++
Class_name name(const Class_name)
```
当函数按值传递对象，函数返回对象时，都将使用复制构造函数。
默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制）。

成员函数或独立函数返回对象时，可以返回指向对象的引用、指向对象的const引用、const对象。

返回对象将调用复制构造函数，返回引用不会。
引用指向的对象应该在调用函数执行时存在。
如果方法或函数返回局部对象，不能返回引用。
如果要返回一个没有公有复制构造函数的类的对象，必须返回引用。
对于可以返回对象也可以返回引用的情况，应首选引用，因为效率更高。


**构造函数中成员初始化列表**
```c++
Classy::Classy() : mem1(10), mem2(20) {...}
```




