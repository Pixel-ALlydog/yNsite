---
date: 2023-12-14
title: 09.内存模型和名称空间
weight: 9
---
# 9. 内存模型和名称空间
## 9.1 存储持续性、作用域和链接性

**存储持续性**\
自动存储持续性：在程序开始执行其所属的代码块时被创建，执行完时，内存被释放。\
静态存储持续性：在函数外或使用static定义的变量，在程序运行的过程中都存在。\
动态存储持续性：用new分配的内存将一直存在，直到使用delete。

### 9.1.2 作用域和链接
作用域描述了名称在文件的多大范围内可见，在名称空间中声明的变量作用域为整个名称空间。

默认情况下，自动存储作用域为局部，没有链接性。由于自动变量的数目随函数的开始和结束而增减，因此程序必须在运行中对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈。

~~register关键字可以指出该变量是自动变量，（以前有用，现在没用c++11后，保留的原因是防止保留了关键字的代码非法）~~

c++为静态存储持续性变量提供了3种链接性，未初始化的所有位都设为0：
- 外部链接性（可在其它文件中访问）
- 内部链接性（只能在当前文件访问）
- 无链接性（只能在当前函数或代码块中访问）

链接性为外部的静态持续变量，必须在代码块的外面声明;\
链接性为内部的静态持续变量，必须在代码块外面声明，并使用static;\
没有链接性的静态持续变量，必须在代码块内声明，并使用static;


**外部链接性**
链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函数而言都是外部的。因此相对于局部的自动变量，外部变量也称全局变量。


**内部链接性**
static用于作用域为整个文件的变量时，该变量的链接性将是内部的。内部的变量只能在其所属的文件中使用。具有外部链接性的变量可以在其他文件中使用。


**无链接性**
只能在代码块中使用，但代码块不活动时仍然存在。


### 9.1.3 说明符和限定符
- auto（c++11中不再是说明符）
- register（没啥用）
- static
- extern
- thread_local（c++11新增）
- mutable

static被用在作用域为整个文件的声明中时，表内部链接性；被用于局部声明中，表明局部变量的存储持续性为静态的。

extern表明是引用声明，声明引用在其他地方定义的变量。

thread_local指出变量的持续性与其所属线程的持续性相同。

mutale指出，即使结构或类变量为const，其某个成员也可以被修改。

**cv-限定符**
- const
- volatile

volatile表明即使程序代码没有对内存进行修改，其值可能发生变化。假设编译器发现，程序在几条语句中多次使用了某个变量的值，则编译器不会让程序多次查找这个值，而是将这个值缓存到寄存器中，这种优化假设变量的值在这两次使用之间不会变化，编译器会默认进行优化。将变量声明为volatile，告诉编译器，不进行这种优化。


在c++中，const对默认存储类型稍有影响。默认情况下全局变量的链接性为外部，但const全局变量的链接性为内部(类似static)。


### 9.1.4 函数和链接性
c++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性都自动为静态的，会在整个程序执行期间一直存在。
默认情况下，函数链接性为外部的，可以在文件间共享，也有使用static声明为内部，使其只能在一个文件中使用。

**语言链接性**\
在C中链接程序要求每个不同函数都有不同的符号名，一个名称对应一个函数。\
在C++中同一个名称可能对应多个函数，必须将这些函数翻译为不同的符号名称。因此C++编译器执行名称矫正，为重载函数生成不同的符号名称。这种方法称为C++语言链接性。


**存储方案和动态分配**\
动态内存由new和delete控制，因此可以在一个函数中分配动态内存，在另一个函数中释放。
通常编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量，另一块用于动态存储。

**定位new运算符**\
通常new负责在堆中找一块能满足要求的内存块。可以使用定位new运算符指定使用的位置。
```c++
#include<new>
struct chaff{
    char dross[20];
    int slage;
};
char buffer1[50];
char buffer2[500];
int main()
{
    chaff *p1, *p2;
    int *p3, *p4;
    p1 = new chaff;
    p3 = new int[20];
    p2 = new (buffer1) chaff;
    p4 = new (buffer2) int [20];
}

```


## 9.2 名称空间
声明区域(declaration region)：是可以在其中进行声明的区域\
潜在作用域(potential scope)：变量的潜在作用域从声明点开始，到其声明区域的结尾。

c++关于全局和局部变量的规则定义了一种名称空间层次，每个声明区域都可以声明名称，这些名称独立于在其他在其他声明区域中声明的名称。

使用namespace创建名称空间：
```c++
namespace Jack
{
    double pall;
    void fetch();
    int pal;
}

namespace Jill
{
    int pal;
    double fetch;
    struck Hill{ ... };
}
```
名称空间可以是全局的，也可以位于另一个名称空间中，不能位于代码块中。默认情况下，在名称空间声明的名称的链接性为外部。


using声明能使特定的标识符可用，using编译指令使整个名称空间可用。
```c++
#include<iostream>
using Jill::fetch;      //使一个名称可用，::为作用域解析运算符
using namespace std;    //使该名称空间全局可用
```

**未命名的名称空间**
无法显示的使用using，不能在未命名名称空间所属文件之外的其他文件中使用该名称空间的名称。是链接性为内部的静态变量的替代品。