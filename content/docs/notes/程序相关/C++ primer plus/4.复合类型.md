---
date: 2023-12-08
title: 04.复合类型
weight: 4
---
# 4. 复合类型
基于基本整型和浮点类型创建，为了满足更复杂的数据要求。

## 4.1 数组
数组声明应指出：
- 存储在每个元素中的值的类型
- 数组名
- 数组中的元素

数组是使用其他类型来创建的，所以是复合类型，没有通用的数组类型，但存在很多特定的数组类型。

## 4.2 字符串
有两种处理字符串的方式，一种是C-风格字符串(C-style string)，另一种是基于string类库的方法。

C-风格字符串以空字符'\0'作为结尾，一些初始化方法
```c++
char dog[3] = {'b', 'e', 'g'};   //不是字符串
char cat[3] = {'b', 'e', '\0'};   //是字符串

char bird[11] = "Mr.Cheeps";    //会隐式的包括空字符
char fish [] = "Bublles";

```
cout打印dog中的3个字母后，会接着将内存之后的各个字节解释为要打印的字符，直到遇到空字符为止。因为空字符在内存中很常见，这个过程会很快停止。


关于string类，需要使用头文件string，也支持C-风格的初始化方式。
```c++
string str = {"Mr.Cheeps"};
string str1("Hello");
```


**字符串输入**
cin的一些方法：
1. getline()：通过换行符确定输入结尾
2. get()：与getline()类似，但不会读取并丢弃换行符，换行符会留在输入流中。


## 4.3 结构体
结构是用户定义的类型，结构声明定义了这种类型的数据属性。使用struct关键字进行声明：
```c++
struct Node
{
    int value;
    Node* next;
}

Node p;     //有了类型后就可以创建变量了
```

**共用体**
共用体可以存储不同的数据类型，但只能同时存储其中的一种类型，使用union进行声明：
```c++
union one4all
{
    int int_val;
    float float_val;
    long long_val;
}

one4all.int = 10;       //存储int
std::cout << one4all.int << ' ';   
one4all.float = 2.5;    //存储float，int丢失
std::cout << ont4all.float;
```


## 4.4 枚举
enum提供了另一种创建符号常量的方式，可以代以const，语法与结构类似：
```c++
enum spectrum {red, orange, yellow, green};
spectrum band;

band = red;     //yse!
band = 10;      //no!
```
- spectrun是新的类型名称，这被称为枚举
- red、orange等作为符号常量，对应整数0-3。称为枚举量

在没有强制类型转换的情况下，只能将定义的枚举量赋给枚举的变量。

**枚举量的值**
指定的值必须是整数，可以创建多个值相同的枚举量，后面没有被初始化的枚举量的值比前面的枚举量大1。
```c++
enum bits{one = 1, two = 2, four};  //这里four值为3
enum {zero, null = 0, numero_uno = 1};
```

## 4.5 指针和自由存储空间
程序的运行阶段指的是程序正在运行时的阶段，编译阶段是编译器将程序组合起来时。
在编译时给数组分配内存被称为静态联编(static binding)，在运行阶可以选择是否创建并且选择长度，这被称为动态联编(dynamic binding)。
OOP强调在运行阶段做决策，可以根据当时的情况进行调整，这使得程序更灵活。

指针用来存储值的地址，声明指针必须指定指针指向的数据类型。
```c++
int* ptr;   //int* 是复合类型，存储地址，是指向int的指针，
int data = 10;
ptr = &data;    //通过&(地址运算符)访问值的地址
std::cout << *ptr;  //通过*(解引用运算符)来访问指向的值
```
地址默认用十六进制来表示（这很方便）。

c++创建指针时，只会分配存储地址的内存，不会分配地址指向数据的内存。
可以使用new为其分配内存。
使用delete释放new分配的内存
```c++
int *ptr = new int;
delete ptr;
```
>*注意：*
> - 当内存不够时，new会引发异常。
> - c++中，值为0的指针被称为空指针(null pointer)
> - c++确保空指针不会指向有效的数据，所以常被用来表示运算符或函数失败
> - 不要使用delete来释放不是new分配的内存
> - 不要使用delete释放同一内存两次
> - 使用new[]为数组分配内存，应使用delete[]释放
> - 使用new[]为一个实体分配内存，应使用delete释放

**指针算术**
在c++中，数组和指针基本等价。
```c++
int a[4] = {1,2,3,4};
int *ap = a;        //数组名为首个值的地址，大小为sizeof(int)，
//int (*ap)[4] = &a     &a则表示整个数组的地址，大小为sizeof(a)*4，地址看起来是一样的，但ap+1会指到下个数组(也许有的话。。。)。
cout << *ap;
cout << *(ap+1);     //指针地址会增加sizeof(int)，即存放下个值的地址
```

## 4.6 自动存储、静态存储和动态存储
c++有3中管理内存的方式：自动存储、静态存储、动态存储。

**自动存储**
在函数内部定义的常量变量使用自动存储空间，被称为自动变量(automatic variable)，在函数被调用时自动产生，在函数结束时消亡。
是一个局部变量，作用域为包含它的代码块。通常存储在栈中，遵循后进先出。

**静态存储**
时整个程序执行期间存在的存储方式。有两种方式使变量成为静态变量：在函数外定义或使用关键字static

**动态存储**
由new和delete管理的内存池，在c++中称为自由存储空间(free store)或堆(heap)。
该内存池与静态变量和自动变量的内存是分开的。因此数据的生命周期不完全受程序和函数生存的时间控制。

在栈中自动添加和删除机制使得占用的内存总是连续的，new和delete的相互影响可能导致自由存储区不连续，这会导致跟踪新分配内存的位置更困难。

>如果使用new分配内存后没有调用delete，即使指针由于作用域规则和对象生命周期的原因被释放，在自由存储空间上动态分配的变量或结构也会继续存在。
>实际上，将会无法访问自由存储空间中的结构，这将导致内存泄漏。被泄漏的内存将在程序的整个生命周期内都不可用。内存被分配出去，却无法回收。
>极端情况下，内存泄漏非常严重，可能导致程序可用的内存被耗尽，出现内存耗尽错误，导致程序崩溃。

