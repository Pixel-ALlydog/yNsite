---
date: 2023-12-18
title: 10.对象和类
weight: 10
---

# 10. 对象和类
## 10.1 抽象和类
在c++中，用户定义类型指的是实现抽象接口的类设计。
一般情况下，类规范由两部分：
- 类声明：以数据成员的方法描述数据部分，以成员函数的方法描述公有接口
- 类方法定义：描述如何实现类成员函数

通常将类声明分成两部分组成，这两部分通常保存在不同的文件中，类声明在头文件中，定义成员函数放在另一个文件中，这样便将接口描述与实现细节分开了。
  
**访问控制**
默认下，类成员为私有，可以使用public、protected和private描述对类成员的访问控制。
使用类对象的程序可以直接访问公有部分，私有成员只能通过公有函数访问。
防止程序直接访问数据被称为数据隐藏(将数据放在类的私有部分)。

将实现细节放在一起并将它们与抽象分开被称为封装，数据隐藏式一种封装。

**类和结构**
c++对结构进行了扩展，使之具有与类相同的特征。
结构默认访问类型为public，类为private。
通常使用类来实现类描述，使用结构限制为只表示纯粹的数据对象。

**内联方法**
定义位于类声明中的函数都将自动称为内联函数，也可以在外部定义成员函数，需要inline：
```c++
class Stock
{
private:
    void set_tot();
public:
    ...
}

inline void Stock::set_tot()
{
    ...
}
```
内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义，在类声明中定义方法等同于用原型替换方法定义，然后在类声明的后面将定义改写为内联函数。


## 10.2构造函数和析构函数
**构造函数**
类构造函数专门用于构造新对象，使用构造函数对类成员初始化，构造函数没有声明类型。构造函数被用来创建对象，不能通过对象来调用。

若没有定义构造函数，c++会自动提供默认构造函数
```c++
Stock::Stroc() { }
```

**析构函数**
创建对象后，程序负责跟踪该对象，直到过去为止，析构函数完成清理工作。如果构造函数使用new来分配内存，析构函数将使用delete来释放内存。
```c++
Stock::~Stock() { }
```
对于静态存储对象，析构函数在程序结束时调用，对于自动存储对象，在程序执行完代码块时自动调用析构函数。


**const成员函数**
const成员函数确保函数不会修改调用对象。
```c++
void Stock::fun(const int);     //传入const变量
const Stock Stock::fun();       //返回const变量
void Stock::fun() const;        //const成员函数，确保函数不会修改调用对象
```

## 10.3 this指针和类作用域
**this**
this表示当前类型的对象

**类作用域**
类中定义的名称作用域为整个类

**作用域为类的常量**
声明类只是描述了对象的形式，并没有创建对象，意味着没有用于存储值的空间。
```c++
class years
{
    const int Mon = 12;     //不行
    enum{Mon = 12};         //行
    static const int Months = 12; //行
}
```
作用域内枚举不能隐式的转为整形。


## 10.4 抽象数据类型
抽象数据类型（abstract data type, ADT）以通用的方式描述数据类型，没有引入语言或实现细节。

>ADT是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而在计算机内部如何表示和实现无关，即不论其内部结构如何变化，只要数学特性不变，都不影响其外部的使用。


## 10.5 运算符重载
c++允许将运算符重载扩展到用户定义的类型。
```c++
operator(argument-list)
```
重载后的运算符必须至少有一个操作数是用户定义的类型\
使用运算符时不能违反运算符原来的句法规则\
不能创建新运算符\
下面的运算符只能通过成员函数进行重载：
- =
- ()
- []
- ->

对于很多运算符，可以选择使用成员函数或非成员函数来实现运算符重载。\
对于某些运算符来说成员函数是唯一合法选择，在其他情况下两种格式没有太大区别。

## 10.6 友元
友元提供了另一种访问类对象私有成员的形式，可以分为3种：
- 友元函数
- 友元类
- 友元成员函数
  
让函数成为友元，可以赋予函数与类的成员函数相同的访问权限。


### 10.6.1 友元函数
有时会遇到以下问题：
```c++
Time operator*(const Time & t);   //假设这是成员函数
Time operator*(double m);   //假设这是成员函数
Time A,B;
A = A * B;   //会转成A.operator*(B)
A = A * 2.5; //会转成A.operator*(2.5)
A = 2.5 * A; //不行，2.5不是对象，无法调用operator*
```
如果定义一个非成员函数，但还是有问题：
```c++
Time operator*(double m, const Time & t); //假设这是非成员函数
A = 2.5 * A;    //理论上会转为operator*(2.5, A)，但由于是非成员函数，operator*无法访问A中的成员，无法运算
```
这时就可以使用友元函数：
```c++
friend Time operator*(double m, const Time & t);
A = 2.5 * A;    //会转为operator*(2.5, A)
```
友元函数是非成员函数，但有成员函数的访问权限。

**重载<<运算符**
```c++
void operator<<(ostream & os);  //假设为成员函数
cout << A;      //cout不是成员对象，无法调用operator<<
A << cout;     //只能这么用，会很奇怪A.operator<<(cout)

friend void operator<<(ostream & os, const Time & t);     //非成员函数
cout << A;      //operator<<(cout, A) 
```
但这仍然会有问题，需要返回ostream的引用。
```c++
friend void operator<<(ostream & os, const Time & t);
cout << "now Time: " << A << ' ';   //无法这么用

friend ostream & operator<<(ostream & os, const Time & t);
cout << "now Time: " << A << ' ';   
```

关于cout:
```c++
int x = 5, y = 8;
cout << x << y;     //等同于(cout << x) << y;
```
<<运算符要求左边是一个ostream对象，cout为ostream对象，所以cout<< x可以输出，而cout << x 位于 << y左侧，所以cout<< x需要返回一个ostream对象（不是返回ostream类）。因此operator<<()函数实现为返回一个指向ostream对象的引用。


## 10.7 类的自动转换和强制类型转换
在c++中，接受一个参数的构造函数可以作为转换函数：
```c++
Node(int n);    //假设这是构造函数

Node p;
p = 10;     //c++会使用Node(10)临时创建一个Node对象赋给p，这个过程是隐式的
```
可以使用explicit关闭这种自动特性。
```c++
explicit Node(int n);
```

**转换函数**
构造函数只能用于从某种类型到类类型的转换，使用转换函数可以进行相反的转换。
转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用。
```c++
operator typeName();

//如operator double();
```
- 转换函数必须是类方法
- 转换函数不能指定返回类型
- 转换函数不能有参数

**自动应用类型转换**
若类中只定义了一种转换，编译器会隐式的调用。


